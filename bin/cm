#!/usr/bin/env bash
set -euo pipefail
trap 'echo "Exit status $? at line $LINENO from: $BASH_COMMAND"' ERR

#/ Run Claude Code inside a Docker container.
#/
#/ Usage: cm [options] [profile]
#/ Options:
#/   --env             Only export environment variables, don't run Claude
#/   --print, -p       Activate Claude's print mode
#/   --raw-output      Output raw JSON (only with --print)
#/   --force-rebuild   Force rebuild of Docker image
#/   --no-build-cache  Build from scratch without using cache
#/   --claude-help     Show Claude help
#/   --help            Show this help

# Check for bash.
if [ -z "${BASH_VERSION:-}" ]; then
    echo "Error: This script requires bash" >&2
    exit 1
fi

if ! command -v docker &> /dev/null; then
    echo "Error: Docker is not installed" >&2
    exit 1
fi

if ! docker info &> /dev/null; then
    echo "Error: Docker daemon is not running" >&2
    exit 1
fi

if ! command -v bc &> /dev/null; then
    echo "Error: bc is not installed" >&2
    exit 1
fi

if ! command -v toml &> /dev/null; then
    echo "Error: toml-cli is not installed" >&2
    exit 1
fi

if ! command -v jq &> /dev/null; then
    echo "Error: jq is not installed" >&2
    exit 1
fi

if ! command -v realpath &> /dev/null; then
    echo "Error: realpath is not installed" >&2
    exit 1
fi

devel_dir="$(realpath "$HOME/devel")"
if [[ ! -d "$devel_dir" ]]; then
    echo "Error: $HOME/devel does not exist" >&2
    exit 1
fi

current_dir="$(realpath "$(pwd)")"
if [[ "$current_dir" != "$devel_dir"* ]]; then
    echo "Error: not inside ~/devel" >&2
    exit 1
fi

project_relative_dir="${current_dir#"$devel_dir"/}"
if [[ -z "$project_relative_dir" ]]; then
    echo "Error: Cannot run from ~/devel root, must be in a subdirectory" >&2
    exit 1
fi

env_only=false
show_help=false
show_claude_help=false
print_mode=false
raw_output=false
force_rebuild=false
no_build_cache=false
profile=""
claude_args=()

for arg in "$@"; do
    case "$arg" in
        --env)
            env_only=true
            ;;
        --claude-help)
            show_claude_help=true
            ;;
        --help)
            show_help=true
            ;;
        --print | -p)
            if [[ "$print_mode" == "false" ]]; then
                print_mode=true
            fi
            ;;
        --raw-output)
            raw_output=true
            ;;
        --force-rebuild)
            force_rebuild=true
            ;;
        --no-build-cache)
            no_build_cache=true
            ;;
        -*)
            claude_args+=("$arg")
            ;;
        *)
            if [[ -z "$profile" && "$arg" != "" ]]; then
                profile="$arg"
            else
                claude_args+=("$arg")
            fi
            ;;
    esac
done

if [[ "$raw_output" == "true" && "$print_mode" == "false" ]]; then
    echo "Warning: --raw-output has no effect without --print" >&2
fi

if [[ "$show_help" == "true" ]]; then
    grep '^#/' "${BASH_SOURCE[0]}" | cut -c4-
    exit 0
fi

username="$(whoami)"
dockerfile_path="$devel_dir/dotfiles/references/Dockerfile.ai_agents"

build_image() {
    local today="$1"
    local use_cache="$2"

    echo "Building Docker image..." >&2
    local build_args=(
        -f "$dockerfile_path"
        --target claude
        --build-arg USERNAME="$username"
        --build-arg BUILD_DATE="$today"
    )

    if [[ "$use_cache" == "false" ]]; then
        echo "Building from scratch without cache..." >&2
        build_args+=(--no-cache)
    fi

    build_args+=(
        -t "$username-claude:latest"
        "$devel_dir/dotfiles"
    )

    if docker build "${build_args[@]}" >&2; then
        # Clean up dangling images.
        if ! docker image prune -f >&2 2> /dev/null; then
            echo "Warning: Could not clean up dangling Docker images" >&2
        fi
        return 0
    else
        echo "Warning: Docker build failed" >&2
        # Clean up dangling images.
        if ! docker image prune -f >&2 2> /dev/null; then
            echo "Warning: Could not clean up dangling Docker images" >&2
        fi
        return 1
    fi
}

generate_container_name() {
    local dir_basename=$(basename "$current_dir")
    echo "oc_${dir_basename:0:53}_$(shuf -i 1-999999 -n 1)"
}

# Run Claude Code in Docker container.
# Usage: run_claude [--exec] [--minimal] [args...]
# --exec: Use exec to replace current process
# --minimal: Skip mounts and environment, just run with --rm
run_claude() {
    local use_exec=false
    local minimal=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --exec)
                use_exec=true
                shift
                ;;
            --minimal)
                minimal=true
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    local cmd=(docker run)

    # Only use -it if stdin is a TTY.
    if [ -t 0 ] && [ -t 1 ]; then
        cmd+=(-it)
    # In print mode, we still want to allocate a TTY so that we get the output
    # from the Claude Code process in a format that's easier to process (one
    # JSON object per line).
    elif [[ "$print_mode" == "true" ]]; then
        cmd+=(-t)
    fi

    container_home="/home/$username"

    if [[ "$minimal" == "true" ]]; then
        cmd+=(--init --rm --name "$(generate_container_name)" "$username-claude:latest" "$@")
    else
        cmd+=(--init --rm --name "$(generate_container_name)" --user "$(id -u):$(id -g)")

        cmd+=(-v "$current_dir:$container_home/devel/$project_relative_dir")

        # If this is not the main Git worktree, also mount the main worktree.
        if [ -f "$current_dir/.git" ]; then
            # .git is a file, not a directory - this is not the main worktree.
            main_worktree=$(
                git worktree list --porcelain \
                    | grep -m1 "^worktree " | cut -d' ' -f2
            )
            main_worktree_realpath=$(realpath "$main_worktree")

            if [[ "$main_worktree_realpath" != "$devel_dir"* ]]; then
                echo "Error: Main worktree must be in ~/devel" >&2
                exit 1
            fi

            # Calculate relative path from `$devel_dir`.
            main_worktree_relative="${main_worktree_realpath#"$devel_dir"/}"
            cmd+=(
                -v "$main_worktree_realpath:$container_home/devel/$main_worktree_relative"
            )
        fi

        # Mount my dotfiles so symlinks work.
        if [ "$current_dir" != "$devel_dir/dotfiles" ]; then
            cmd+=(-v "$devel_dir/dotfiles:$container_home/devel/dotfiles:ro")
        fi

        # Mount additional projects from `AGENTS_ADDITIONAL_PROJECTS`.
        if [ -n "${AGENTS_ADDITIONAL_PROJECTS:-}" ]; then
            IFS=',' read -ra ADDITIONAL_PROJECTS <<< "$AGENTS_ADDITIONAL_PROJECTS"
            for project in "${ADDITIONAL_PROJECTS[@]}"; do
                # Trim whitespace.
                project=$(xargs <<< "$project")
                if [ -n "$project" ]; then
                    project_path="$devel_dir/$project"
                    if [ -d "$project_path" ]; then
                        cmd+=(-v "$project_path:$container_home/devel/$project:ro")
                    else
                        echo "Warning: Additional project '$project' does not exist at $project_path" >&2
                    fi
                fi
            done
        fi

        cmd+=(
            -v "$devel_dir/dotfiles/bin/ai_commit:/usr/local/bin/ai_commit:ro"
            -v "$devel_dir/dotfiles/bin/safe_rm:/usr/local/bin/safe_rm:ro"
            -v "$devel_dir/dotfiles/bin/ralph:/usr/local/bin/ralph:ro"
            -v "$devel_dir/dotfiles/bin/review_diff:/usr/local/bin/review_diff:ro"
            -v "$HOME/.config/git:$container_home/.config/git:ro"
        )

        cmd+=(
            -v "$HOME/.claude:$container_home/.claude"
            -v "$HOME/.claude.json:$container_home/.claude.json"
        )

        cmd+=(
            -e CLAUDE_CODE_API_KEY
            -e GH_TOKEN
        )

        cmd+=(
            -w "$container_home/devel/$project_relative_dir"
            "$username-claude:latest"
            "$@"
        )
    fi

    echo "Running container..." >&2

    if [[ "$use_exec" == "true" ]]; then
        exec "${cmd[@]}"
    else
        "${cmd[@]}"
    fi
}

last_build_date_file="$HOME/.claude/.last-docker-build.date"
last_build_mtime_file="$HOME/.claude/.last-docker-build.mtime"
today=$(date +%Y-%m-%d)

mkdir -p "$(dirname "$last_build_date_file")"
if [[ ! -f "$last_build_date_file" ]]; then
    echo "never" > "$last_build_date_file"
fi
if [[ ! -f "$last_build_mtime_file" ]]; then
    echo "0" > "$last_build_mtime_file"
fi

dockerfile_mtime=$(stat -c %Y "$dockerfile_path" 2> /dev/null || stat -f %m "$dockerfile_path" 2> /dev/null || echo "0")
last_build_date=$(cat "$last_build_date_file")
last_build_mtime=$(cat "$last_build_mtime_file")

if [[ "$force_rebuild" == "true" ]] \
    || [[ "$last_build_date" != "$today" ]] \
    || [[ "$dockerfile_mtime" -gt "$last_build_mtime" ]]; then
    use_cache="true"
    if [[ "$no_build_cache" == "true" ]]; then
        use_cache="false"
    fi
    if ! build_image "$today" "$use_cache"; then
        if ! docker image inspect "$username-claude:latest" > /dev/null 2>&1; then
            echo "Error: Docker image does not exist and build failed" >&2
            exit 1
        fi
        echo "" >&2
        echo "========================================" >&2
        echo "WARNING: BUILD FAILED - OLD IMAGE EXISTS" >&2
        echo "========================================" >&2
        echo "The Docker build failed, but an older image is available." >&2
        echo "This image may have outdated dependencies or be missing recent fixes." >&2
        echo "" >&2
        read -p "Do you want to continue with the old image? [y/N] " -n 1 -r >&2
        echo "" >&2
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Aborted by user" >&2
            exit 1
        fi
        echo "Continuing with existing Docker image..." >&2
    else
        echo "$today" > "$last_build_date_file"
        echo "$dockerfile_mtime" > "$last_build_mtime_file"
    fi
fi

if [[ "$show_claude_help" == "true" ]]; then
    run_claude --exec --minimal --help
fi

if [ -z "$profile" ]; then
    component_count=$(tr '/' '\n' <<< "$project_relative_dir" | wc -l)
    if [ "$component_count" -gt 1 ]; then
        profile="$(cut -d'/' -f1 <<< "$project_relative_dir")"
    else
        profile="$username"
    fi
fi

echo "Running Claude Code with profile '$profile'..." >&2

# Validate profile name to prevent command injection.
# Max length: 64 characters, alphanumeric with dots, dashes, underscores.
if [[ ! "$profile" =~ ^[a-zA-Z0-9_]([a-zA-Z0-9._-]{0,62}[a-zA-Z0-9_])?$ ]]; then
    echo "Error: Invalid profile name '$profile'" >&2
    exit 1
fi

if [ -z "${CLAUDE_CODE_API_KEY+x}" ]; then
    echo -n "Fetching Claude Code configuration from 1Password..." >&2
    if ! CLAUDE_CODE_SECRET=$(op read "op://Private/Claude Code Configuration/notesPlain" 2>&1); then
        echo "Error: Failed to retrieve Claude Code configuration from 1Password" >&2
        echo "Make sure you are logged in to 1Password CLI (run: op signin)" >&2
        exit 1
    fi
    echo " done!" >&2

    # Validate secret is valid TOML before using it.
    if ! toml get <(echo "$CLAUDE_CODE_SECRET") profile > /dev/null 2>&1; then
        echo "Error: Retrieved secret is not valid TOML or missing 'profile' section" >&2
        exit 1
    fi

    if ! CLAUDE_CODE_API_KEY=$(toml get <(echo "$CLAUDE_CODE_SECRET") . | jq -r --arg p "$profile" '.profile[$p].api_key'); then
        echo "Error: Failed to parse Claude Code configuration" >&2
        exit 1
    fi

    if [[ "$CLAUDE_CODE_API_KEY" == "null" || -z "$CLAUDE_CODE_API_KEY" ]]; then
        echo "Warning: no API key for profile '$profile', defaulting to '$username'" >&2
        if ! CLAUDE_CODE_API_KEY=$(toml get <(echo "$CLAUDE_CODE_SECRET") . | jq -r --arg u "$username" '.profile[$u].api_key'); then
            echo "Error: Failed to retrieve default API key" >&2
            exit 1
        fi
        if [[ "$CLAUDE_CODE_API_KEY" == "null" || -z "$CLAUDE_CODE_API_KEY" ]]; then
            echo "Error: No valid API key found" >&2
            exit 1
        fi
    fi
fi

if [ -z "${GH_TOKEN+x}" ]; then
    echo -n "Fetching GitHub token from 1Password..." >&2
    if ! GH_TOKEN=$(op read "op://Private/GH Token/notesPlain" 2>&1); then
        echo "Error: Failed to retrieve GH_TOKEN from 1Password" >&2
        echo "Make sure you are logged in to 1Password CLI (run: op signin)" >&2
        exit 1
    fi
    echo " done!" >&2

    if [[ -z "$GH_TOKEN" ]]; then
        echo "Error: GH_TOKEN is empty" >&2
        exit 1
    fi
fi

if [[ "$env_only" == "true" ]]; then
    # Output shell commands to be eval'd for environment variable export.
    printf "export CLAUDE_CODE_API_KEY=%q\n" "$CLAUDE_CODE_API_KEY"
    printf "export GH_TOKEN=%q\n" "$GH_TOKEN"
    echo "Environment variables exported for profile '$profile'" >&2
    exit 0
fi

export CLAUDE_CODE_API_KEY
export GH_TOKEN

# Function to round cost up to the next cent for display.
round_up_cents() {
    local value=$1
    local rounded=$(bc <<< "scale=0; tmp = $value * 100; tmp = tmp / 1; if (tmp < $value * 100) tmp = tmp + 1; scale=2; tmp / 100")
    printf "%.2f" "$rounded"
}

# Function to format duration as XhYmZ.WWWs.
format_duration() {
    local total_seconds=$1

    # Handle zero or empty input.
    if [[ -z "$total_seconds" ]] || [[ $(bc <<< "$total_seconds == 0") -eq 1 ]]; then
        echo "0.000s"
        return
    fi

    local hours=$(bc <<< "$total_seconds / 3600")
    local remainder=$(bc <<< "$total_seconds - ($hours * 3600)")
    local minutes=$(bc <<< "$remainder / 60")
    local seconds=$(bc <<< "$remainder - ($minutes * 60)")

    local result=""
    if [ "$hours" -gt 0 ]; then
        result="${hours}h"
    fi
    if [ "$minutes" -gt 0 ] || [ "$hours" -gt 0 ]; then
        result="${result}${minutes}m"
    fi
    result="${result}$(printf "%.3f" "$seconds")s"
    echo "$result"
}

mkdir -p "$HOME/.claude"

# Read from stdin if available (for piped input).
message=""
if [ ! -t 0 ]; then
    message=$(cat)
fi

if [[ "$print_mode" == "true" ]]; then
    # In print mode, a message is REQUIRED.
    if [ -z "$message" ]; then
        echo "Error: Print mode requires a message via stdin" >&2
        exit 1
    fi

    if [[ "$raw_output" == "true" ]]; then
        run_claude --exec --print --output-format json "$message"
    else
        OUTPUT=$(run_claude --print --output-format json "$message")

        RESULT=$(jq -r '.result // ""' <<< "$OUTPUT")
        COST=$(jq -r '.total_cost_usd // 0' <<< "$OUTPUT")
        DURATION_MS=$(jq -r '.duration_ms // 0' <<< "$OUTPUT")

        DURATION=$(printf "%.3f" "$(bc <<< "scale=3; $DURATION_MS / 1000")")

        echo "$RESULT"
        echo "" >&2
        echo "Cost: \$$(round_up_cents "$COST")" >&2
        echo "Duration: $(format_duration "$DURATION")" >&2
    fi
else
    # In non-print mode, a message is NOT ALLOWED.
    if [ -n "$message" ]; then
        echo "Error: Non-print mode does not accept stdin. Use --print or -p for message input" >&2
        exit 1
    fi

    run_claude --exec "${claude_args[@]}"
fi
