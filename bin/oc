#!/usr/bin/env bash
set -euo pipefail
trap 'echo "Exit status $? at line $LINENO from: $BASH_COMMAND"' ERR

#/ Run OpenCode inside a Docker container.
#/
#/ Usage: oc [options] [profile]
#/ Options:
#/   --print, -p       Activate OpenCode's print mode
#/   --raw-output      Output raw JSON (only with --print)
#/   --force-rebuild   Force rebuild of Docker image
#/   --opencode-help   Show OpenCode help
#/   --help            Show this help

# Check for bash.
if [ -z "${BASH_VERSION:-}" ]; then
    echo "Error: This script requires bash" >&2
    exit 1
fi

if ! command -v docker &> /dev/null; then
    echo "Error: Docker is not installed" >&2
    exit 1
fi

if ! docker info &> /dev/null; then
    echo "Error: Docker daemon is not running" >&2
    exit 1
fi

if ! command -v bc &> /dev/null; then
    echo "Error: bc is not installed" >&2
    exit 1
fi

if ! command -v toml &> /dev/null; then
    echo "Error: toml-cli is not installed" >&2
    exit 1
fi

if ! command -v jq &> /dev/null; then
    echo "Error: jq is not installed" >&2
    exit 1
fi

if ! command -v realpath &> /dev/null; then
    echo "Error: realpath is not installed" >&2
    exit 1
fi

devel_dir="$(realpath "$HOME/devel")"
if [[ ! -d "$devel_dir" ]]; then
    echo "Error: $HOME/devel does not exist" >&2
    exit 1
fi

current_dir="$(realpath "$(pwd)")"
if [[ "$current_dir" != "$devel_dir"* ]]; then
    echo "Error: not inside ~/devel" >&2
    exit 1
fi

project_relative_dir="${current_dir#"$devel_dir"/}"
if [[ -z "$project_relative_dir" ]]; then
    echo "Error: Cannot run from ~/devel root, must be in a subdirectory" >&2
    exit 1
fi

show_help=false
show_opencode_help=false
print_mode=false
raw_output=false
force_rebuild=false
profile=""
opencode_args=()

for arg in "$@"; do
    case "$arg" in
        --opencode-help)
            show_opencode_help=true
            ;;
        --help)
            show_help=true
            ;;
        --print | -p)
            if [[ "$print_mode" == "false" ]]; then
                print_mode=true
            fi
            ;;
        --raw-output)
            raw_output=true
            ;;
        --force-rebuild)
            force_rebuild=true
            ;;
        -*)
            opencode_args+=("$arg")
            ;;
        *)
            if [[ -z "$profile" && "$arg" != "" ]]; then
                profile="$arg"
            else
                opencode_args+=("$arg")
            fi
            ;;
    esac
done

if [[ "$raw_output" == "true" && "$print_mode" == "false" ]]; then
    echo "Warning: --raw-output has no effect without --print" >&2
fi

if [[ "$show_help" == "true" ]]; then
    grep '^#/' "${BASH_SOURCE[0]}" | cut -c4-
    exit 0
fi

username="$(whoami)"

build_image() {
    local today="$1"
    local last_build_file="$2"

    echo "Building Docker image..." >&2
    if docker build \
        -f "$devel_dir/dotfiles/references/Dockerfile.opencode" \
        --build-arg USERNAME="$username" \
        --build-arg BUILD_DATE="$today" \
        -t "$username-opencode:latest" \
        "$devel_dir/dotfiles" >&2; then
        # Clean up dangling images.
        if ! docker image prune -f >&2 2> /dev/null; then
            echo "Warning: Could not clean up dangling Docker images" >&2
        fi
        return 0
    else
        echo "Warning: Docker build failed" >&2
        # Clean up dangling images.
        if ! docker image prune -f >&2 2> /dev/null; then
            echo "Warning: Could not clean up dangling Docker images" >&2
        fi
        return 1
    fi
}

# Run OpenCode in Docker container.
# Usage: run_opencode [--exec] [--minimal] [args...]
# --exec: Use exec to replace current process
# --minimal: Skip mounts and environment, just run with --rm
run_opencode() {
    local use_exec=false
    local minimal=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --exec)
                use_exec=true
                shift
                ;;
            --minimal)
                minimal=true
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    local cmd=(docker run)

    # Only use -it if stdin is a TTY
    if [ -t 0 ] && [ -t 1 ]; then
        cmd+=(-it)
    fi

    container_home="/home/$username"

    if [[ "$minimal" == "true" ]]; then
        cmd+=(--rm "$username-opencode:latest" "$@")
    else
        cmd+=(--rm --user "$(id -u):$(id -g)")

        cmd+=(-v "$current_dir:$container_home/devel/$project_relative_dir")

        # If this is not the main Git worktree, also mount the main worktree.
        if [ -f "$current_dir/.git" ]; then
            # .git is a file, not a directory - this is not the main worktree.
            main_worktree=$(
                git worktree list --porcelain \
                    | grep -m1 "^worktree " | cut -d' ' -f2
            )
            main_worktree_realpath=$(realpath "$main_worktree")

            if [[ "$main_worktree_realpath" != "$devel_dir"* ]]; then
                echo "Error: Main worktree must be in ~/devel" >&2
                exit 1
            fi

            # Calculate relative path from `$devel_dir`.
            main_worktree_relative="${main_worktree_realpath#"$devel_dir"/}"
            cmd+=(
                -v "$main_worktree_realpath:$container_home/devel/$main_worktree_relative:ro"
            )
        fi

        # Mount my dotfiles so symlinks work.
        if [ "$current_dir" != "$devel_dir/dotfiles" ]; then
            cmd+=(-v "$devel_dir/dotfiles:$container_home/devel/dotfiles:ro")
        fi

        # Mount additional projects from `AGENTS_ADDITIONAL_PROJECTS`.
        if [ -n "${AGENTS_ADDITIONAL_PROJECTS:-}" ]; then
            IFS=',' read -ra ADDITIONAL_PROJECTS <<< "$AGENTS_ADDITIONAL_PROJECTS"
            for project in "${ADDITIONAL_PROJECTS[@]}"; do
                # Trim whitespace.
                project=$(echo "$project" | xargs)
                if [ -n "$project" ]; then
                    project_path="$devel_dir/$project"
                    if [ -d "$project_path" ]; then
                        cmd+=(-v "$project_path:$container_home/devel/$project:ro")
                    else
                        echo "Warning: Additional project '$project' does not exist at $project_path" >&2
                    fi
                fi
            done
        fi

        cmd+=(
            -v "$devel_dir/dotfiles/bin/ai_commit:/usr/local/bin/ai_commit:ro"
            -v "$devel_dir/dotfiles/bin/safe_rm:/usr/local/bin/safe_rm:ro"
            -v "$devel_dir/dotfiles/bin/ralph:/usr/local/bin/ralph:ro"
            -v "$devel_dir/dotfiles/bin/review_diff:/usr/local/bin/review_diff:ro"
            -v "$HOME/.config/git:$container_home/.config/git:ro"
        )

        cmd+=(
            -v "$HOME/.config/opencode:$container_home/.config/opencode:ro"
            -v "$HOME/.local/state/opencode:$container_home/.local/state/opencode"
            -v "$HOME/.local/share/opencode:$container_home/.local/share/opencode"
        )

        cmd+=(
            -e OPENCODE_DISABLE_MODELS_FETCH=1
            -e OPENCODE_DISABLE_CLAUDE_CODE=true
            -e OPENCODE_API_KEY
            -e CLAUDE_CODE_API_KEY
            -e GH_TOKEN
        )

        # Pass OPENCODE_CONFIG_CONTENT if defined in environment.
        if [ -n "${OPENCODE_CONFIG_CONTENT:-}" ]; then
            cmd+=(-e OPENCODE_CONFIG_CONTENT)
        fi

        cmd+=(
            -w "$container_home/devel/$project_relative_dir"
            "$username-opencode:latest"
            "$@"
        )
    fi

    if [[ "$use_exec" == "true" ]]; then
        exec "${cmd[@]}"
    else
        "${cmd[@]}"
    fi
}

last_build_file="$HOME/.config/opencode/.last-docker-build"
last_build_mtime_file="$HOME/.config/opencode/.last-docker-build.mtime"
today=$(date +%Y-%m-%d)

mkdir -p "$(dirname "$last_build_file")"
if [[ ! -f "$last_build_file" ]]; then
    echo "never" > "$last_build_file"
fi
if [[ ! -f "$last_build_mtime_file" ]]; then
    echo "0" > "$last_build_mtime_file"
fi

dockerfile_path="$devel_dir/dotfiles/references/Dockerfile.opencode"
dockerfile_mtime=$(stat -c %Y "$dockerfile_path" 2> /dev/null || stat -f %m "$dockerfile_path" 2> /dev/null || echo "0")
last_build_date=$(cat "$last_build_file")
last_build_mtime=$(cat "$last_build_mtime_file")

if [[ "$force_rebuild" == "true" ]] \
    || [[ "$last_build_date" != "$today" ]] \
    || [[ "$dockerfile_mtime" -gt "$last_build_mtime" ]]; then
    if ! build_image "$today" "$last_build_file"; then
        if ! docker image inspect "$username-opencode:latest" > /dev/null 2>&1; then
            echo "Error: Docker image does not exist and build failed" >&2
            exit 1
        fi
        echo "" >&2
        echo "========================================" >&2
        echo "WARNING: BUILD FAILED - OLD IMAGE EXISTS" >&2
        echo "========================================" >&2
        echo "The Docker build failed, but an older image is available." >&2
        echo "This image may have outdated dependencies or be missing recent fixes." >&2
        echo "" >&2
        read -p "Do you want to continue with the old image? [y/N] " -n 1 -r >&2
        echo "" >&2
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Aborted by user" >&2
            exit 1
        fi
        echo "Continuing with existing Docker image..." >&2
    else
        echo "$today" > "$last_build_file"
        echo "$dockerfile_mtime" > "$last_build_mtime_file"
    fi
fi

if [[ "$show_opencode_help" == "true" ]]; then
    run_opencode --exec --minimal --help
fi

if [ -z "$profile" ]; then
    component_count=$(echo "$project_relative_dir" | tr '/' '\n' | wc -l)
    if [ "$component_count" -gt 1 ]; then
        profile="$(echo "$project_relative_dir" | cut -d'/' -f1)"
    else
        profile="$username"
    fi
fi

# Validate profile name to prevent command injection.
# Max length: 64 characters, alphanumeric with dots, dashes, underscores.
if [[ ! "$profile" =~ ^[a-zA-Z0-9_]([a-zA-Z0-9._-]{0,62}[a-zA-Z0-9_])?$ ]]; then
    echo "Error: Invalid profile name '$profile'" >&2
    exit 1
fi

if [ -z "${OPENCODE_API_KEY+x}" ]; then
    if ! OPENCODE_SECRET=$(op read "op://Private/OpenCode Configuration/notesPlain" 2>&1); then
        echo "Error: Failed to retrieve OpenCode configuration from 1Password" >&2
        echo "Make sure you are logged in to 1Password CLI (run: op signin)" >&2
        exit 1
    fi

    # Validate secret is valid TOML before using it.
    if ! toml get <(echo "$OPENCODE_SECRET") profile > /dev/null 2>&1; then
        echo "Error: Retrieved secret is not valid TOML or missing 'profile' section" >&2
        exit 1
    fi

    if ! OPENCODE_API_KEY=$(toml get <(echo "$OPENCODE_SECRET") . | jq -r --arg p "$profile" '.profile[$p].opencode_zen_api_key'); then
        echo "Error: Failed to parse OpenCode configuration" >&2
        exit 1
    fi

    if [[ "$OPENCODE_API_KEY" == "null" || -z "$OPENCODE_API_KEY" ]]; then
        echo "Warning: no OpenCode API key for profile '$profile', defaulting to '$username'" >&2
        if ! OPENCODE_API_KEY=$(toml get <(echo "$OPENCODE_SECRET") . | jq -r --arg u "$username" '.profile[$u].opencode_zen_api_key'); then
            echo "Error: Failed to retrieve default OpenCode API key" >&2
            exit 1
        fi
        if [[ "$OPENCODE_API_KEY" == "null" || -z "$OPENCODE_API_KEY" ]]; then
            echo "Error: No valid OpenCode API key found" >&2
            exit 1
        fi
    fi
fi

if [ -z "${CLAUDE_CODE_API_KEY+x}" ]; then
    if [[ -z "${OPENCODE_SECRET:-}" ]]; then
        if ! OPENCODE_SECRET=$(op read "op://Private/OpenCode Configuration/notesPlain" 2>&1); then
            echo "Error: Failed to retrieve OpenCode configuration from 1Password" >&2
            echo "Make sure you are logged in to 1Password CLI (run: op signin)" >&2
            exit 1
        fi

        # Validate secret is valid TOML before using it.
        if ! toml get <(echo "$OPENCODE_SECRET") profile > /dev/null 2>&1; then
            echo "Error: Retrieved secret is not valid TOML or missing 'profile' section" >&2
            exit 1
        fi
    fi

    if ! CLAUDE_CODE_API_KEY=$(toml get <(echo "$OPENCODE_SECRET") . | jq -r --arg p "$profile" '.profile[$p].claude_code_api_key'); then
        echo "Error: Failed to parse Claude Code API key from OpenCode configuration" >&2
        exit 1
    fi

    if [[ "$CLAUDE_CODE_API_KEY" == "null" || -z "$CLAUDE_CODE_API_KEY" ]]; then
        echo "Warning: no Claude Code API key for profile '$profile', defaulting to '$username'" >&2
        if ! CLAUDE_CODE_API_KEY=$(toml get <(echo "$OPENCODE_SECRET") . | jq -r --arg u "$username" '.profile[$u].claude_code_api_key'); then
            echo "Error: Failed to retrieve default Claude Code API key" >&2
            exit 1
        fi
        if [[ "$CLAUDE_CODE_API_KEY" == "null" || -z "$CLAUDE_CODE_API_KEY" ]]; then
            echo "Error: No valid Claude Code API key found" >&2
            exit 1
        fi
    fi
fi

if [ -z "${GH_TOKEN+x}" ]; then
    if ! GH_TOKEN=$(op read "op://Private/GH Token/notesPlain" 2>&1); then
        echo "Error: Failed to retrieve GH_TOKEN from 1Password" >&2
        echo "Make sure you are logged in to 1Password CLI (run: op signin)" >&2
        exit 1
    fi
    if [[ -z "$GH_TOKEN" ]]; then
        echo "Error: GH_TOKEN is empty" >&2
        exit 1
    fi
fi

# Function to round cost up to the next cent for display.
round_up_cents() {
    local value=$1
    local rounded=$(echo "scale=0; tmp = $value * 100; tmp = tmp / 1; if (tmp < $value * 100) tmp = tmp + 1; scale=2; tmp / 100" | bc)
    printf "%.2f" "$rounded"
}

# Function to format duration as XhYmZ.WWWs.
format_duration() {
    local total_seconds=$1

    # Handle zero or empty input.
    if [[ -z "$total_seconds" ]] || [[ $(echo "$total_seconds == 0" | bc) -eq 1 ]]; then
        echo "0.000s"
        return
    fi

    local hours=$(echo "$total_seconds / 3600" | bc)
    local remainder=$(echo "$total_seconds - ($hours * 3600)" | bc)
    local minutes=$(echo "$remainder / 60" | bc)
    local seconds=$(echo "$remainder - ($minutes * 60)" | bc)

    local result=""
    if [ "$hours" -gt 0 ]; then
        result="${hours}h"
    fi
    if [ "$minutes" -gt 0 ] || [ "$hours" -gt 0 ]; then
        result="${result}${minutes}m"
    fi
    result="${result}$(printf "%.3f" "$seconds")s"
    echo "$result"
}

export OPENCODE_API_KEY
export CLAUDE_CODE_API_KEY
export GH_TOKEN

mkdir -p "$HOME/.config/opencode" "$HOME/.local/state/opencode"

echo "Running OpenCode with profile '$profile'" >&2
echo "" >&2

# Read from stdin if available (for piped input).
message=""
if [ ! -t 0 ]; then
    message=$(cat)
fi

if [[ "$print_mode" == "true" ]]; then
    # In print mode, a message is REQUIRED.
    if [ -z "$message" ]; then
        echo "Error: Print mode requires a message via stdin" >&2
        exit 1
    fi

    if [[ "$raw_output" == "true" ]]; then
        run_opencode --exec run --format json "$message"
    else
        OUTPUT=$(run_opencode run --format json "$message")

        # Extract text from the last text part.
        RESULT=$(echo "$OUTPUT" | jq -r '[select(.type == "text")] | last | .part.text // ""')

        # Get first and last timestamps to calculate duration.
        FIRST_TS=$(echo "$OUTPUT" | head -n 1 | jq -r '.timestamp // 0')
        LAST_TS=$(echo "$OUTPUT" | tail -n 1 | jq -r '.timestamp // 0')
        DURATION_MS=$((LAST_TS - FIRST_TS))
        DURATION=$(printf "%.3f" "$(echo "scale=3; $DURATION_MS / 1000" | bc)")

        # Sum up costs from all steps.
        COST=$(echo "$OUTPUT" | jq -s 'map(.part.cost // 0) | add')

        echo "$RESULT"
        echo "" >&2
        echo "Cost: \$$(round_up_cents "$COST")" >&2
        echo "Duration: $(format_duration "$DURATION")" >&2
    fi
else
    # In non-print mode, a message is NOT ALLOWED.
    if [ -n "$message" ]; then
        echo "Error: Non-print mode does not accept stdin. Use --print or -p for message input" >&2
        exit 1
    fi

    run_opencode --exec "${opencode_args[@]}"
fi
