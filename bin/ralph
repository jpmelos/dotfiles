#!/usr/bin/env bash
set -e

# Ralph - Long-running AI agent loop
#
# Usage:
#   ralph [max_iterations]
#
# Environment:
#   CLAUDE_CODE_API_KEY   If set, uses Claude Code. Otherwise prompts user.
#   OPENCODE_API_KEY      If set, uses OpenCode. Otherwise prompts user.
#
#   If neither is set, prompts user to choose (defaults to OpenCode).
#   If both are set, prompts user to choose (defaults to OpenCode).
#
# Files:
#   jpenv-ralph/tickets.json - Engineering tickets (required)
#   jpenv-ralph/progress.txt - Progress log (auto-created)

# Check for uncommitted changes (staged or unstaged).
if ! git diff-index --quiet HEAD --; then
    echo "Error: Working directory has uncommitted changes" >&2
    echo "Commit or stash changes before running Ralph" >&2
    exit 1
fi

# Check for untracked files (excluding ignored files).
if [ -n "$(git ls-files --others --exclude-standard)" ]; then
    echo "Error: Working directory has untracked files" >&2
    echo "Commit, ignore, or remove untracked files before running Ralph" >&2
    exit 1
fi

# Determine which AI service to use and ensure API key is available.
RALPH_CMD=""

has_claude_key=false
has_opencode_key=false

[ -n "$CLAUDE_CODE_API_KEY" ] && has_claude_key=true
[ -n "$OPENCODE_API_KEY" ] && has_opencode_key=true

if [ "$has_claude_key" = true ] && [ "$has_opencode_key" = true ]; then
    # Both are defined, ask user which to use.
    echo "Both OpenCode and Claude Code API keys are defined."
    read -p "Which service would you like to use? [(o)pencode/(c)laude] (default: opencode): " choice
    choice=${choice:-opencode}
    case "$choice" in
        claude | c)
            RALPH_CMD="cm"
            ;;
        opencode | o | oc | *)
            RALPH_CMD="oc"
            ;;
    esac
elif [ "$has_opencode_key" = true ]; then
    # Only OpenCode API key is defined.
    RALPH_CMD="oc"
    echo "Using OpenCode (API key found in environment)" >&2
elif [ "$has_claude_key" = true ]; then
    # Only Claude Code API key is defined.
    RALPH_CMD="cm"
    echo "Using Claude Code (API key found in environment)" >&2
else
    # Neither is defined, ask user which to use.
    echo "No API keys found in environment."
    read -p "Which service would you like to use? [(o)pencode/(c)laude] (default: opencode): " choice
    choice=${choice:-opencode}
    case "$choice" in
        claude | c)
            RALPH_CMD="cm"
            ;;
        opencode | o | oc | *)
            RALPH_CMD="oc"
            ;;
    esac

    # Export environment variables for the chosen service.
    if command -v "$RALPH_CMD" &> /dev/null; then
        eval "$("$RALPH_CMD" --env)"
    else
        echo "Error: '$RALPH_CMD' command not found in PATH" >&2
        exit 1
    fi
fi

# Verify the command is available.
if ! command -v "$RALPH_CMD" &> /dev/null; then
    echo "Error: '$RALPH_CMD' command not found in PATH" >&2
    exit 1
fi

echo "Using '$RALPH_CMD' for Ralph" >&2

MAX_ITERATIONS=${1:-10}
if ! [[ "$MAX_ITERATIONS" =~ ^[0-9]+$ ]] || [ "$MAX_ITERATIONS" -lt 1 ]; then
    echo "Error: MAX_ITERATIONS must be a positive integer" >&2
    exit 1
fi

RALPH_DIR="jpenv-ralph"
mkdir -p "$RALPH_DIR"
TICKETS_FILE="$RALPH_DIR/tickets.json"
PROGRESS_FILE="$RALPH_DIR/progress.txt"
LOG_FILE="$RALPH_DIR/log.log"
STATE_FILE="$RALPH_DIR/state.json"

# Check if tickets file exists.
if [ ! -f "$TICKETS_FILE" ]; then
    echo "Error: Tickets file not found at $TICKETS_FILE" >&2
    exit 1
fi

# Initialize progress file if it doesn't exist.
if [ ! -f "$PROGRESS_FILE" ]; then
    echo "# Ralph Progress Log" > "$PROGRESS_FILE"
    echo "Started: $(date "+%Y-%m-%d %H:%M")" >> "$PROGRESS_FILE"
    echo "---" >> "$PROGRESS_FILE"
fi

# Function to log to both stdout and file.
log() {
    local message="$*"
    echo "$message"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $message" >> "$LOG_FILE"
}

# Function to round cost up to the next cent for display.
round_up_cents() {
    local value=$1
    local rounded=$(echo "scale=0; tmp = $value * 100; tmp = tmp / 1; if (tmp < $value * 100) tmp = tmp + 1; scale=2; tmp / 100" | bc)
    printf "%.2f" "$rounded"
}

# Function to format duration as XhYmZ.WWWs.
format_duration() {
    local total_seconds=$1
    local hours=$(echo "$total_seconds / 3600" | bc)
    local remainder=$(echo "$total_seconds - ($hours * 3600)" | bc)
    local minutes=$(echo "$remainder / 60" | bc)
    local seconds=$(echo "$remainder - ($minutes * 60)" | bc)

    local result=""
    if [ "$hours" -gt 0 ]; then
        result="${hours}h"
    fi
    if [ "$minutes" -gt 0 ] || [ "$hours" -gt 0 ]; then
        result="${result}${minutes}m"
    fi
    result="${result}$(printf "%.3f" "$seconds")s"
    echo "$result"
}

log "Starting Ralph"
log "Max iterations: $MAX_ITERATIONS"

TOTAL_COST=0
TOTAL_DURATION=0
START_ITERATION=1

# Load state if resuming from a previous run.
if [ -f "$STATE_FILE" ]; then
    log ""
    log "Found existing state file - resuming from previous run"

    if ! TOTAL_COST=$(jq -e -r '.total_cost // 0' "$STATE_FILE" 2> /dev/null); then
        echo "Error: Failed to parse state file at $STATE_FILE" >&2
        echo "The state file may be corrupt. Please remove it and start fresh." >&2
        exit 1
    fi
    if ! TOTAL_DURATION=$(jq -e -r '.total_duration // 0' "$STATE_FILE" 2> /dev/null); then
        echo "Error: Failed to parse state file at $STATE_FILE" >&2
        echo "The state file may be corrupt. Please remove it and start fresh." >&2
        exit 1
    fi
    if ! LAST_COMPLETED_ITERATION=$(jq -e -r '.last_completed_iteration // 0' "$STATE_FILE" 2> /dev/null); then
        echo "Error: Failed to parse state file at $STATE_FILE" >&2
        echo "The state file may be corrupt. Please remove it and start fresh." >&2
        exit 1
    fi
    if ! SAVED_COMMIT=$(jq -e -r '.last_commit // ""' "$STATE_FILE" 2> /dev/null); then
        echo "Error: Failed to parse state file at $STATE_FILE" >&2
        echo "The state file may be corrupt. Please remove it and start fresh." >&2
        exit 1
    fi

    # Verify that the current HEAD matches the saved commit.
    CURRENT_COMMIT=$(git rev-parse HEAD)
    if [ -n "$SAVED_COMMIT" ] && [ "$SAVED_COMMIT" != "$CURRENT_COMMIT" ]; then
        echo "Error: Repository state has changed since last run" >&2
        echo "Expected commit: $SAVED_COMMIT" >&2
        echo "Current commit:  $CURRENT_COMMIT" >&2
        echo "Please reset to the expected commit or remove the state file to start fresh." >&2
        exit 1
    fi

    START_ITERATION=$((LAST_COMPLETED_ITERATION + 1))

    log "Resuming from iteration $START_ITERATION"
    log "Previous total cost: \$$(round_up_cents "$TOTAL_COST")"
    log "Previous total duration: $(format_duration "$TOTAL_DURATION")"
fi

for i in $(seq "$START_ITERATION" "$MAX_ITERATIONS"); do
    log ""
    log "═══════════════════════════════════════════════════════"
    log "  Iteration $i of $MAX_ITERATIONS"
    log "═══════════════════════════════════════════════════════"
    log "Started: $(date "+%Y-%m-%d %H:%M:%S")"
    log ""

    OUTPUT=$(cat "$HOME/ralph/prompt.md" | "$RALPH_CMD" -p --raw-output)

    # Extract result and metrics from JSON output.
    # The format differs between OpenCode and Claude Code.
    if [ "$RALPH_CMD" = "cm" ]; then
        # Claude Code output is a single JSON object.
        RESULT=$(echo "$OUTPUT" | jq -r '.result // ""')
        ITERATION_COST=$(echo "$OUTPUT" | jq -r '.total_cost_usd // 0')
        ITERATION_DURATION_MS=$(echo "$OUTPUT" | jq -r '.duration_ms // 0')
    else
        # OpenCode output is newline-delimited JSON.
        # Extract text from the last text part.
        RESULT=$(echo "$OUTPUT" | jq -r '[select(.type == "text")] | last | .part.text // ""')

        # Sum up costs from all steps.
        ITERATION_COST=$(echo "$OUTPUT" | jq -s 'map(.part.cost // 0) | add')

        # Get first and last timestamps to calculate duration.
        FIRST_TS=$(echo "$OUTPUT" | head -n 1 | jq -r '.timestamp // 0')
        LAST_TS=$(echo "$OUTPUT" | tail -n 1 | jq -r '.timestamp // 0')
        ITERATION_DURATION_MS=$((LAST_TS - FIRST_TS))
    fi

    log "$RESULT"

    # Convert milliseconds to seconds.
    ITERATION_DURATION=$(printf "%.3f" "$(echo "scale=3; $ITERATION_DURATION_MS / 1000" | bc)")

    # Update totals.
    TOTAL_COST=$(echo "$TOTAL_COST + $ITERATION_COST" | bc)
    TOTAL_DURATION=$(echo "$TOTAL_DURATION + $ITERATION_DURATION" | bc)

    log ""
    log "Iteration cost: \$$(round_up_cents "$ITERATION_COST")"
    log "Iteration duration: $(format_duration "$ITERATION_DURATION")"
    log "Total cost so far: \$$(round_up_cents "$TOTAL_COST")"
    log "Total duration so far: $(format_duration "$TOTAL_DURATION")"

    # Save state after each iteration.
    jq -n \
        --arg iteration "$i" \
        --arg cost "$TOTAL_COST" \
        --arg duration "$TOTAL_DURATION" \
        --arg timestamp "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
        --arg commit "$(git rev-parse HEAD)" \
        '{
            last_completed_iteration: ($iteration | tonumber),
            total_cost: ($cost | tonumber),
            total_duration: ($duration | tonumber),
            last_updated: $timestamp,
            last_commit: $commit
        }' > "$STATE_FILE.tmp" && mv "$STATE_FILE.tmp" "$STATE_FILE"

    # Check if all tickets are marked as done.
    TICKETS_REMAINING=$(jq '[.tickets[] | select(.done == false)] | length' "$TICKETS_FILE")
    if [ "$TICKETS_REMAINING" -eq 0 ]; then
        log ""
        log "═══════════════════════════════════════════════════════"
        log "  Done!"
        log "═══════════════════════════════════════════════════════"
        log ""
        log "Ralph completed all tasks!"
        log "Completed at iteration $i of $MAX_ITERATIONS."
        log "Total cost: \$$(round_up_cents "$TOTAL_COST")"
        log "Total duration: $(format_duration "$TOTAL_DURATION")"

        # Clear state file on successful completion.
        rm -f "$STATE_FILE"
        exit 0
    fi
done

log ""
log "═══════════════════════════════════════════════════════"
log "  Giving up!"
log "═══════════════════════════════════════════════════════"
log ""
log "Ralph used up all allowed iterations ($MAX_ITERATIONS) without completing all tasks."
log "Total cost: \$$(round_up_cents "$TOTAL_COST")"
log "Total duration: $(format_duration "$TOTAL_DURATION")"

log ""
log "State saved. Run 'ralph' again to automatically resume."
exit 1
