#!/usr/bin/env bash
set -e

# Ralph - Long-running AI agent loop
#
# Usage:
#   ralph [max_iterations]
#
# Environment:
#   CLAUDE_CODE_API_KEY   If set, uses Claude Code. Otherwise prompts user.
#   OPENCODE_API_KEY      If set, uses OpenCode. Otherwise prompts user.
#
#   If neither is set, prompts user to choose (defaults to OpenCode).
#   If both are set, prompts user to choose (defaults to OpenCode).
#
# Files:
#   jpenv-scratch/ralph-tickets.json - Engineering tickets (required)
#   jpenv-scratch/ralph-progress.txt - Progress log (auto-created)

if ! git diff-index --quiet HEAD --; then
    echo "Warning: Working directory has uncommitted changes" >&2
    echo "Commit or stash changes before running Ralph" >&2
    exit 1
fi

# Determine which AI service to use and ensure API key is available.
RALPH_CMD=""

has_claude_key=false
has_opencode_key=false

[ -n "$CLAUDE_CODE_API_KEY" ] && has_claude_key=true
[ -n "$OPENCODE_API_KEY" ] && has_opencode_key=true

if [ "$has_claude_key" = true ] && [ "$has_opencode_key" = true ]; then
    # Both are defined, ask user which to use.
    echo "Both OpenCode and Claude Code API keys are defined."
    read -p "Which service would you like to use? [(o)pencode/(c)laude] (default: opencode): " choice
    choice=${choice:-opencode}
    case "$choice" in
        claude | c)
            RALPH_CMD="cm"
            ;;
        opencode | o | oc | *)
            RALPH_CMD="oc"
            ;;
    esac
elif [ "$has_opencode_key" = true ]; then
    # Only OpenCode API key is defined.
    RALPH_CMD="oc"
    echo "Using OpenCode (API key found in environment)" >&2
elif [ "$has_claude_key" = true ]; then
    # Only Claude Code API key is defined.
    RALPH_CMD="cm"
    echo "Using Claude Code (API key found in environment)" >&2
else
    # Neither is defined, ask user which to use.
    echo "No API keys found in environment."
    read -p "Which service would you like to use? [(o)pencode/(c)laude] (default: opencode): " choice
    choice=${choice:-opencode}
    case "$choice" in
        claude | c)
            RALPH_CMD="cm"
            ;;
        opencode | o | oc | *)
            RALPH_CMD="oc"
            ;;
    esac

    # Export environment variables for the chosen service.
    if command -v "$RALPH_CMD" &> /dev/null; then
        eval "$("$RALPH_CMD" --env)"
    else
        echo "Error: '$RALPH_CMD' command not found in PATH" >&2
        exit 1
    fi
fi

# Verify the command is available.
if ! command -v "$RALPH_CMD" &> /dev/null; then
    echo "Error: '$RALPH_CMD' command not found in PATH" >&2
    exit 1
fi

echo "Using '$RALPH_CMD' for Ralph" >&2

MAX_ITERATIONS=${1:-10}
if ! [[ "$MAX_ITERATIONS" =~ ^[0-9]+$ ]] || [ "$MAX_ITERATIONS" -lt 1 ]; then
    echo "Error: MAX_ITERATIONS must be a positive integer" >&2
    exit 1
fi

mkdir -p jpenv-scratch
TICKETS_FILE="jpenv-scratch/ralph-tickets.json"
PROGRESS_FILE="jpenv-scratch/ralph-progress.txt"
LOG_FILE="jpenv-scratch/ralph.log"

# Check if tickets file exists.
if [ ! -f "$TICKETS_FILE" ]; then
    echo "Error: Tickets file not found at $TICKETS_FILE" >&2
    exit 1
fi

# Initialize progress file if it doesn't exist.
if [ ! -f "$PROGRESS_FILE" ]; then
    echo "# Ralph Progress Log" > "$PROGRESS_FILE"
    echo "Started: $(date "+%Y-%m-%d %H:%M")" >> "$PROGRESS_FILE"
    echo "---" >> "$PROGRESS_FILE"
fi

# Function to log to both stdout and file.
log() {
    local message="$*"
    echo "$message"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $message" >> "$LOG_FILE"
}

# Function to round cost up to the next cent for display.
round_up_cents() {
    local value=$1
    local rounded=$(echo "scale=0; tmp = $value * 100; tmp = tmp / 1; if (tmp < $value * 100) tmp = tmp + 1; scale=2; tmp / 100" | bc)
    printf "%.2f" "$rounded"
}

log "Starting Ralph"
log "Max iterations: $MAX_ITERATIONS"

TOTAL_COST=0
TOTAL_DURATION=0
TOTAL_API_DURATION=0

for i in $(seq 1 "$MAX_ITERATIONS"); do
    log ""
    log "═══════════════════════════════════════════════════════"
    log "  Iteration $i of $MAX_ITERATIONS"
    log "═══════════════════════════════════════════════════════"
    log ""

    OUTPUT=$(cat "$HOME/ralph/prompt.md" | "$RALPH_CMD" -p --raw-output)

    # Extract result and metrics from JSON output.
    # The format differs between OpenCode and Claude Code.
    if [ "$RALPH_CMD" = "cm" ]; then
        # Claude Code output is a single JSON object.
        RESULT=$(echo "$OUTPUT" | jq -r '.result // ""')
        ITERATION_COST=$(echo "$OUTPUT" | jq -r '.total_cost_usd // 0')
        ITERATION_DURATION_MS=$(echo "$OUTPUT" | jq -r '.duration_ms // 0')
        ITERATION_API_DURATION_MS=$(echo "$OUTPUT" | jq -r '.duration_api_ms // 0')
    else
        # OpenCode output is newline-delimited JSON.
        # Extract text from the last text part.
        RESULT=$(echo "$OUTPUT" | jq -r 'select(.type == "text") | .part.text // ""' | tail -n 1)

        # Get cost from the last line.
        ITERATION_COST=$(echo "$OUTPUT" | tail -n 1 | jq -r '.part.cost // 0')

        # Get first and last timestamps to calculate duration.
        FIRST_TS=$(echo "$OUTPUT" | head -n 1 | jq -r '.timestamp // 0')
        LAST_TS=$(echo "$OUTPUT" | tail -n 1 | jq -r '.timestamp // 0')
        ITERATION_DURATION_MS=$((LAST_TS - FIRST_TS))

        # OpenCode doesn't provide API duration separately.
        ITERATION_API_DURATION_MS=0
    fi

    log "$RESULT"

    # Convert milliseconds to seconds.
    ITERATION_DURATION=$(printf "%.3f" "$(echo "scale=3; $ITERATION_DURATION_MS / 1000" | bc)")
    ITERATION_API_DURATION=$(printf "%.3f" "$(echo "scale=3; $ITERATION_API_DURATION_MS / 1000" | bc)")

    # Update totals.
    TOTAL_COST=$(echo "$TOTAL_COST + $ITERATION_COST" | bc)
    TOTAL_DURATION=$(echo "$TOTAL_DURATION + $ITERATION_DURATION" | bc)
    TOTAL_API_DURATION=$(echo "$TOTAL_API_DURATION + $ITERATION_API_DURATION" | bc)

    log ""
    log "Iteration cost: \$$(round_up_cents "$ITERATION_COST")"
    log "Iteration duration: ${ITERATION_DURATION}s (API: ${ITERATION_API_DURATION}s)"
    log "Total cost so far: \$$(round_up_cents "$TOTAL_COST")"
    log "Total duration so far: $(printf "%.3f" "$TOTAL_DURATION")s (API: $(printf "%.3f" "$TOTAL_API_DURATION")s)"

    if echo "$RESULT" | grep -q "<promise>COMPLETE</promise>"; then
        log ""
        log "═══════════════════════════════════════════════════════"
        log "  Done!"
        log "═══════════════════════════════════════════════════════"
        log ""
        log "Ralph completed all tasks!"
        log "Completed at iteration $i of $MAX_ITERATIONS"
        log "Total cost: \$$(round_up_cents "$TOTAL_COST")"
        log "Total duration: $(printf "%.3f" "$TOTAL_DURATION")s (API: $(printf "%.3f" "$TOTAL_API_DURATION")s)"
        exit 0
    fi
done

log ""
log "═══════════════════════════════════════════════════════"
log "  Giving up!"
log "═══════════════════════════════════════════════════════"
log ""
log "Ralph used up all allowed iterations ($MAX_ITERATIONS) without completing all tasks."
log "Total cost: \$$(round_up_cents "$TOTAL_COST")"
log "Total duration: $(printf "%.3f" "$TOTAL_DURATION")s (API: $(printf "%.3f" "$TOTAL_API_DURATION")s)"
exit 1
