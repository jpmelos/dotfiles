#!/usr/bin/env bash
set -euo pipefail
trap 'echo "Exit status $? at line $LINENO from: $BASH_COMMAND"' ERR

#/ Ralph - Long-running AI agent loop
#/
#/ Usage:
#/   ralph [--validate] TICKETS_FILE [max_iterations]
#/
#/ Examples:
#/   ralph features/auth/auth.tickets.json
#/   ralph features/auth/auth.tickets.json 20
#/   ralph --validate features/auth/auth.tickets.json
#/
#/ Arguments:
#/   --help, -h            Show this help message and exit
#/   --validate            Validate tickets file without executing Ralph
#/                         (useful for pre-flight checks)
#/   TICKETS_FILE          Path to the tickets JSON file (required)
#/   max_iterations        Maximum number of iterations (default: 10)
#/
#/ Environment:
#/   CLAUDE_CODE_API_KEY   If set, uses Claude Code. Otherwise prompts user.
#/   OPENCODE_API_KEY      If set, uses OpenCode. Otherwise prompts user.
#/
#/   If neither is set, prompts user to choose (defaults to OpenCode).
#/   If both are set, prompts user to choose (defaults to OpenCode).

# Show help if requested.
if [ "${1:-}" = "--help" ] || [ "${1:-}" = "-h" ]; then
    grep '^#/' "$0" | sed 's/^#\/ \{0,1\}//'
    exit 0
fi

# Parse arguments.
VALIDATE_ONLY=false
if [ "${1:-}" = "--validate" ]; then
    VALIDATE_ONLY=true
    shift
fi

# Get tickets file from first argument.
TICKETS_FILE="${1:-}"
if [ -z "$TICKETS_FILE" ]; then
    echo "Error: TICKETS_FILE argument is required" >&2
    echo "Usage: ralph [--validate] TICKETS_FILE [max_iterations]" >&2
    exit 1
fi

# Validate tickets file extension.
if [[ ! "$TICKETS_FILE" =~ \.tickets\.json$ ]]; then
    echo "Error: Tickets file must end with .tickets.json" >&2
    echo "Got: $TICKETS_FILE" >&2
    exit 1
fi

# Check if tickets file exists.
if [ ! -f "$TICKETS_FILE" ]; then
    echo "Error: Tickets file not found at $TICKETS_FILE" >&2
    exit 1
fi

# Validate tickets file schema.
validate_tickets_schema() {
    local file="$1"

    # Check if file is valid JSON.
    if ! jq empty "$file" 2> /dev/null; then
        echo "Error: Tickets file is not valid JSON" >&2
        return 1
    fi

    # Check for required top-level fields.
    if ! jq -e 'has("project")' "$file" > /dev/null 2>&1; then
        echo "Error: Missing required field 'project' in tickets file" >&2
        return 1
    fi

    if ! jq -e 'has("description")' "$file" > /dev/null 2>&1; then
        echo "Error: Missing required field 'description' in tickets file" >&2
        return 1
    fi

    if ! jq -e 'has("tickets")' "$file" > /dev/null 2>&1; then
        echo "Error: Missing required field 'tickets' in tickets file" >&2
        return 1
    fi

    # Check top-level field types and non-emptiness.
    if ! jq -e '.project | type == "string" and length > 0' "$file" > /dev/null 2>&1; then
        echo "Error: Field 'project' must be a non-empty string" >&2
        return 1
    fi

    if ! jq -e '.description | type == "string" and length > 0' "$file" > /dev/null 2>&1; then
        echo "Error: Field 'description' must be a non-empty string" >&2
        return 1
    fi

    if ! jq -e '.tickets | type == "array"' "$file" > /dev/null 2>&1; then
        echo "Error: Field 'tickets' must be an array" >&2
        return 1
    fi

    # Check each ticket has required fields.
    local ticket_count=$(jq '.tickets | length' "$file")
    for ((idx = 0; idx < ticket_count; idx++)); do
        local ticket_num=$((idx + 1))

        # Check required fields exist (using has() to check presence, not truthiness).
        if ! jq -e ".tickets[$idx] | has(\"id\")" "$file" > /dev/null 2>&1; then
            echo "Error: Ticket #$ticket_num missing required field 'id'" >&2
            return 1
        fi

        if ! jq -e ".tickets[$idx] | has(\"title\")" "$file" > /dev/null 2>&1; then
            echo "Error: Ticket #$ticket_num missing required field 'title'" >&2
            return 1
        fi

        if ! jq -e ".tickets[$idx] | has(\"description\")" "$file" > /dev/null 2>&1; then
            echo "Error: Ticket #$ticket_num missing required field 'description'" >&2
            return 1
        fi

        if ! jq -e ".tickets[$idx] | has(\"acceptanceCriteria\")" "$file" > /dev/null 2>&1; then
            echo "Error: Ticket #$ticket_num missing required field 'acceptanceCriteria'" >&2
            return 1
        fi

        if ! jq -e ".tickets[$idx] | has(\"notes\")" "$file" > /dev/null 2>&1; then
            echo "Error: Ticket #$ticket_num missing required field 'notes'" >&2
            return 1
        fi

        if ! jq -e ".tickets[$idx] | has(\"done\")" "$file" > /dev/null 2>&1; then
            echo "Error: Ticket #$ticket_num missing required field 'done'" >&2
            return 1
        fi

        # Validate field types and non-emptiness.
        if ! jq -e ".tickets[$idx].id | type == \"number\"" "$file" > /dev/null 2>&1; then
            echo "Error: Ticket #$ticket_num field 'id' must be a number" >&2
            return 1
        fi

        if ! jq -e ".tickets[$idx].title | type == \"string\" and length > 0" "$file" > /dev/null 2>&1; then
            echo "Error: Ticket #$ticket_num field 'title' must be a non-empty string" >&2
            return 1
        fi

        if ! jq -e ".tickets[$idx].description | type == \"string\" and length > 0" "$file" > /dev/null 2>&1; then
            echo "Error: Ticket #$ticket_num field 'description' must be a non-empty string" >&2
            return 1
        fi

        if ! jq -e ".tickets[$idx].acceptanceCriteria | type == \"array\"" "$file" > /dev/null 2>&1; then
            echo "Error: Ticket #$ticket_num field 'acceptanceCriteria' must be an array" >&2
            return 1
        fi

        if ! jq -e ".tickets[$idx].notes | type == \"array\"" "$file" > /dev/null 2>&1; then
            echo "Error: Ticket #$ticket_num field 'notes' must be an array" >&2
            return 1
        fi

        if ! jq -e ".tickets[$idx].done | type == \"boolean\"" "$file" > /dev/null 2>&1; then
            echo "Error: Ticket #$ticket_num field 'done' must be a boolean" >&2
            return 1
        fi

        # Validate acceptanceCriteria contains only non-empty strings and is non-empty.
        local criteria_count=$(jq ".tickets[$idx].acceptanceCriteria | length" "$file")
        if [ "$criteria_count" -eq 0 ]; then
            echo "Error: Ticket #$ticket_num must have at least one acceptanceCriteria" >&2
            return 1
        fi
        for ((cidx = 0; cidx < criteria_count; cidx++)); do
            if ! jq -e ".tickets[$idx].acceptanceCriteria[$cidx] | type == \"string\" and length > 0" "$file" > /dev/null 2>&1; then
                echo "Error: Ticket #$ticket_num acceptanceCriteria[$cidx] must be a non-empty string" >&2
                return 1
            fi
        done

        # Validate notes contains only non-empty strings.
        local notes_count=$(jq ".tickets[$idx].notes | length" "$file")
        for ((nidx = 0; nidx < notes_count; nidx++)); do
            if ! jq -e ".tickets[$idx].notes[$nidx] | type == \"string\" and length > 0" "$file" > /dev/null 2>&1; then
                echo "Error: Ticket #$ticket_num notes[$nidx] must be a non-empty string" >&2
                return 1
            fi
        done
    done

    # Validate ticket IDs are sequential starting from 1.
    local expected_id=1
    for ((idx = 0; idx < ticket_count; idx++)); do
        local actual_id=$(jq ".tickets[$idx].id" "$file")
        if [ "$actual_id" != "$expected_id" ]; then
            echo "Error: Ticket IDs must be sequential starting from 1. Expected ID $expected_id but got $actual_id" >&2
            return 1
        fi
        expected_id=$((expected_id + 1))
    done

    return 0
}

echo "Validating tickets file..."
if ! validate_tickets_schema "$TICKETS_FILE"; then
    echo "Tickets file schema validation failed" >&2
    exit 1
fi
echo "Tickets file is valid!"

# Exit early if only validating (exit 0 on success, 1 on failure).
if [ "$VALIDATE_ONLY" = true ]; then
    # Warn if max_iterations was provided but ignored.
    if [ -n "${2:-}" ]; then
        echo "Warning: max_iterations argument ignored in validate mode" >&2
    fi
    exit 0
fi

# Check if wakepy is available.
if ! command -v wakepy &> /dev/null; then
    echo "Error: wakepy command not found in PATH" >&2
    echo "Please install wakepy to prevent the computer from sleeping during execution" >&2
    exit 1
fi

# Start wakepy and store its PID.
wakepy &> /dev/null &
WAKEPY_PID=$!

# Set up trap to kill wakepy on script exit (normal or abnormal).
cleanup() {
    if [ -n "$WAKEPY_PID" ] && kill -0 "$WAKEPY_PID" 2> /dev/null; then
        kill "$WAKEPY_PID" 2> /dev/null || true
    fi
}
trap cleanup EXIT INT TERM

# Check for uncommitted changes (staged or unstaged).
if ! git diff-index --quiet HEAD --; then
    echo "Error: Working directory has uncommitted changes" >&2
    echo "Commit or stash changes before running Ralph" >&2
    exit 1
fi

# Check for untracked files (excluding ignored files).
if [ -n "$(git ls-files --others --exclude-standard)" ]; then
    echo "Error: Working directory has untracked files" >&2
    echo "Commit, ignore, or remove untracked files before running Ralph" >&2
    exit 1
fi

# Determine which AI service to use and ensure API key is available.
RALPH_CMD=""

has_claude_key=false
has_opencode_key=false

[ -n "${CLAUDE_CODE_API_KEY:-}" ] && has_claude_key=true
[ -n "${OPENCODE_API_KEY:-}" ] && has_opencode_key=true

if [ "$has_claude_key" = true ] && [ "$has_opencode_key" = true ]; then
    # Both are defined, ask user which to use.
    echo "Both OpenCode and Claude Code API keys are defined."
    read -p "Which service would you like to use? [(o)pencode/(c)laude] (default: opencode): " choice
    choice=${choice:-opencode}
    case "$choice" in
        claude | c)
            RALPH_CMD="cm"
            ;;
        opencode | o | oc | *)
            RALPH_CMD="oc"
            ;;
    esac
elif [ "$has_opencode_key" = true ]; then
    # Only OpenCode API key is defined.
    RALPH_CMD="oc"
    echo "Using OpenCode (API key found in environment)" >&2
elif [ "$has_claude_key" = true ]; then
    # Only Claude Code API key is defined.
    RALPH_CMD="cm"
    echo "Using Claude Code (API key found in environment)" >&2
else
    # Neither is defined, ask user which to use.
    echo "No API keys found in environment."
    read -p "Which service would you like to use? [(o)pencode/(c)laude] (default: opencode): " choice
    choice=${choice:-opencode}
    case "$choice" in
        claude | c)
            RALPH_CMD="cm"
            ;;
        opencode | o | oc | *)
            RALPH_CMD="oc"
            ;;
    esac

    # Export environment variables for the chosen service.
    if command -v "$RALPH_CMD" &> /dev/null; then
        eval "$("$RALPH_CMD" --env)"
    else
        echo "Error: '$RALPH_CMD' command not found in PATH" >&2
        exit 1
    fi
fi

# Verify the command is available.
if ! command -v "$RALPH_CMD" &> /dev/null; then
    echo "Error: '$RALPH_CMD' command not found in PATH" >&2
    exit 1
fi

echo "Using '$RALPH_CMD' for Ralph" >&2

# Get max iterations from second argument (default: 10).
MAX_ITERATIONS=${2:-10}
if ! [[ "$MAX_ITERATIONS" =~ ^[0-9]+$ ]] || [ "$MAX_ITERATIONS" -lt 1 ]; then
    echo "Error: MAX_ITERATIONS must be a positive integer" >&2
    exit 1
fi

# Derive base directory and feature name from tickets file.
RALPH_DIR=$(dirname "$TICKETS_FILE")
TICKETS_BASENAME=$(basename "$TICKETS_FILE")
FEATURE_NAME="${TICKETS_BASENAME%.tickets.json}"

# Derive other file paths.
PROGRESS_FILE="$RALPH_DIR/$FEATURE_NAME.progress.md"
LOG_FILE="$RALPH_DIR/$FEATURE_NAME.log"
STATE_FILE="$RALPH_DIR/$FEATURE_NAME.state.json"

# Initialize progress file if it doesn't exist.
if [ ! -f "$PROGRESS_FILE" ]; then
    echo "# Ralph Progress Log: $FEATURE_NAME" > "$PROGRESS_FILE"
    echo "Tickets file: $TICKETS_FILE" >> "$PROGRESS_FILE"
    echo "Started: $(date "+%Y-%m-%d %H:%M")" >> "$PROGRESS_FILE"
    echo "---" >> "$PROGRESS_FILE"
fi

# Function to log to both stdout and file.
log() {
    local message="$*"
    echo "$message"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $message" >> "$LOG_FILE"
}

# Function to round cost up to the next cent for display.
round_up_cents() {
    local value=$1
    local rounded=$(bc <<< "scale=0; tmp = $value * 100; tmp = tmp / 1; if (tmp < $value * 100) tmp = tmp + 1; scale=2; tmp / 100")
    printf "%.2f" "$rounded"
}

# Function to format duration as XhYmZ.WWWs.
format_duration() {
    local total_seconds=$1
    local hours=$(bc <<< "$total_seconds / 3600")
    local remainder=$(bc <<< "$total_seconds - ($hours * 3600)")
    local minutes=$(bc <<< "$remainder / 60")
    local seconds=$(bc <<< "$remainder - ($minutes * 60)")

    local result=""
    if [ "$hours" -gt 0 ]; then
        result="${hours}h"
    fi
    if [ "$minutes" -gt 0 ] || [ "$hours" -gt 0 ]; then
        result="${result}${minutes}m"
    fi
    result="${result}$(printf "%.3f" "$seconds")s"
    echo "$result"
}

# Function to handle state file commit mismatch.
# Modifies: TOTAL_COST, TOTAL_DURATION, START_ITERATION, SAVED_COMMIT.
# Exits with code 1 if user chooses to abort.
handle_state_commit_mismatch() {
    local saved_commit=$1
    local current_commit=$2

    echo "Error: Repository state has changed since last run" >&2
    echo "Expected commit: $saved_commit" >&2
    echo "Current commit: $current_commit" >&2
    echo "" >&2
    echo "What would you like to do?" >&2
    echo "  1. Delete the state file and start from scratch" >&2
    echo "  2. Override the commit SHA to the current value and continue" >&2
    echo "  3. Abort" >&2
    read -p "Enter your choice [1-3]: " choice
    case "$choice" in
        1)
            echo "Deleting state file and starting from scratch..." >&2
            rm -f "$STATE_FILE"
            TOTAL_COST=0
            TOTAL_DURATION=0
            START_ITERATION=1
            ;;
        2)
            echo "Overriding commit SHA to current value and continuing..." >&2
            SAVED_COMMIT="$current_commit"
            ;;
        3)
            echo "Aborting." >&2
            exit 1
            ;;
        *)
            echo "Invalid choice. Aborting." >&2
            exit 1
            ;;
    esac
}

log "Starting Ralph"
log "Max iterations: $MAX_ITERATIONS"

TOTAL_COST=0
TOTAL_DURATION=0
START_ITERATION=1

# Load state if resuming from a previous run.
if [ -f "$STATE_FILE" ]; then
    log ""
    log "Found existing state file - resuming from previous run"

    if ! TOTAL_COST=$(jq -e -r '.total_cost // 0' "$STATE_FILE" 2> /dev/null); then
        echo "Error: Failed to parse state file at $STATE_FILE" >&2
        echo "The state file may be corrupt. Please remove it and start fresh." >&2
        exit 1
    fi
    if ! TOTAL_DURATION=$(jq -e -r '.total_duration // 0' "$STATE_FILE" 2> /dev/null); then
        echo "Error: Failed to parse state file at $STATE_FILE" >&2
        echo "The state file may be corrupt. Please remove it and start fresh." >&2
        exit 1
    fi
    if ! LAST_COMPLETED_ITERATION=$(jq -e -r '.last_completed_iteration // 0' "$STATE_FILE" 2> /dev/null); then
        echo "Error: Failed to parse state file at $STATE_FILE" >&2
        echo "The state file may be corrupt. Please remove it and start fresh." >&2
        exit 1
    fi
    if ! SAVED_COMMIT=$(jq -e -r '.last_commit // ""' "$STATE_FILE" 2> /dev/null); then
        echo "Error: Failed to parse state file at $STATE_FILE" >&2
        echo "The state file may be corrupt. Please remove it and start fresh." >&2
        exit 1
    fi

    # Verify that the current HEAD matches the saved commit.
    CURRENT_COMMIT=$(git rev-parse HEAD)
    if [ -n "$SAVED_COMMIT" ] && [ "$SAVED_COMMIT" != "$CURRENT_COMMIT" ]; then
        handle_state_commit_mismatch "$SAVED_COMMIT" "$CURRENT_COMMIT"
    fi

    START_ITERATION=$((LAST_COMPLETED_ITERATION + 1))
    # When resuming, MAX_ITERATIONS is the number of remaining iterations.
    # Add the current iteration to get the new maximum.
    MAX_ITERATIONS=$((LAST_COMPLETED_ITERATION + MAX_ITERATIONS))

    log "Resuming from iteration $START_ITERATION"
    log "Previous total cost: \$$(round_up_cents "$TOTAL_COST")"
    log "Previous total duration: $(format_duration "$TOTAL_DURATION")"
fi

for i in $(seq "$START_ITERATION" "$MAX_ITERATIONS"); do
    log ""
    log "═══════════════════════════════════════════════════════"
    log "  Iteration $i of $MAX_ITERATIONS"
    log "═══════════════════════════════════════════════════════"
    log "Started: $(date "+%Y-%m-%d %H:%M:%S")"
    log ""

    WORKTREE_STATUS=$(git status)
    PROMPT=$(< "$HOME/ralph/prompt.md")
    PROMPT=${PROMPT//\$ARGUMENTS/tickets_file=$TICKETS_FILE}
    PROMPT=${PROMPT//\$WORKTREE_STATUS/$WORKTREE_STATUS}

    OUTPUT=$("$RALPH_CMD" -p --raw-output <<< "$PROMPT")

    # Extract result and metrics from JSON output.
    # The format differs between OpenCode and Claude Code.
    if [ "$RALPH_CMD" = "cm" ]; then
        # Claude Code output is a single JSON object.
        RESULT=$(jq -r '.result // ""' <<< "$OUTPUT")
        ITERATION_COST=$(jq -r '.total_cost_usd // 0' <<< "$OUTPUT")
        ITERATION_DURATION_MS=$(jq -r '.duration_ms // 0' <<< "$OUTPUT")
    else
        # OpenCode output is newline-delimited JSON.
        # Extract text from the last text part.
        RESULT=$(jq -r '[select(.type == "text")] | last | .part.text // ""' <<< "$OUTPUT")

        # Sum up costs from all steps.
        ITERATION_COST=$(jq -s 'map(.part.cost // 0) | add' <<< "$OUTPUT")

        # Get first and last timestamps to calculate duration.
        FIRST_TS=$(head -n 1 <<< "$OUTPUT" | jq -r '.timestamp // 0')
        LAST_TS=$(tail -n 1 <<< "$OUTPUT" | jq -r '.timestamp // 0')
        ITERATION_DURATION_MS=$((LAST_TS - FIRST_TS))
    fi

    log "$RESULT"

    # Convert milliseconds to seconds.
    ITERATION_DURATION=$(printf "%.3f" "$(bc <<< "scale=3; $ITERATION_DURATION_MS / 1000")")

    # Update totals.
    TOTAL_COST=$(bc <<< "$TOTAL_COST + $ITERATION_COST")
    TOTAL_DURATION=$(bc <<< "$TOTAL_DURATION + $ITERATION_DURATION")

    log ""
    log "Iteration cost: \$$(round_up_cents "$ITERATION_COST")"
    log "Iteration duration: $(format_duration "$ITERATION_DURATION")"
    log "Total cost so far: \$$(round_up_cents "$TOTAL_COST")"
    log "Total duration so far: $(format_duration "$TOTAL_DURATION")"

    # Save state after each iteration.
    jq -n \
        --arg iteration "$i" \
        --arg cost "$TOTAL_COST" \
        --arg duration "$TOTAL_DURATION" \
        --arg timestamp "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
        --arg commit "$(git rev-parse HEAD)" \
        '{
            last_completed_iteration: ($iteration | tonumber),
            total_cost: ($cost | tonumber),
            total_duration: ($duration | tonumber),
            last_updated: $timestamp,
            last_commit: $commit
        }' > "$STATE_FILE.tmp" && mv "$STATE_FILE.tmp" "$STATE_FILE"

    # Check if all tickets are marked as done.
    TICKETS_REMAINING=$(jq '[.tickets[] | select(.done == false)] | length' "$TICKETS_FILE")
    if [ "$TICKETS_REMAINING" -eq 0 ]; then
        log ""
        log "═══════════════════════════════════════════════════════"
        log "  Done!"
        log "═══════════════════════════════════════════════════════"
        log ""
        log "Ralph completed all tasks!"
        log "Completed at iteration $i of $MAX_ITERATIONS."
        log "Total cost: \$$(round_up_cents "$TOTAL_COST")"
        log "Total duration: $(format_duration "$TOTAL_DURATION")"

        exit 0
    fi
done

log ""
log "═══════════════════════════════════════════════════════"
log "  Giving up!"
log "═══════════════════════════════════════════════════════"
log ""
log "Ralph used up all allowed iterations ($MAX_ITERATIONS) without completing all tasks."
log "Total cost: \$$(round_up_cents "$TOTAL_COST")"
log "Total duration: $(format_duration "$TOTAL_DURATION")"

log ""
log "State saved. Run 'ralph' again to automatically resume."
exit 1
